# Foundations

This block sets the baseline for the rest of the course: how to describe algorithms clearly, reason about correctness, and build a first habit of thinking about performance.  

!!! info "What this block is for"
    You’ll use these ideas in every later topic (arrays, trees, graphs). If this block feels solid, everything else becomes easier.

## What you should get from this block
- Write precise algorithm steps **before** you code.
- Explain why an algorithm is correct (in plain language, step by step).
- Notice when a solution will slow down or use too much memory as inputs grow.

!!! tip "How to study (simple routine)"
    Read the lecture notes → solve a small set of tasks → explain your solution out loud (or in writing) → then improve it.

## Key Topics

<div class="grid cards" markdown>

- :material-compass-outline: **Algorithm fundamentals**  
  What an algorithm is, how to write clear steps, and how to think about edge cases.  
  [Open →](alg-foundations.md){ .md-button .md-button--primary }

- :material-timer-sand: **Algorithm analysis**  
  A structured way to compare solutions (time, space, and trade-offs).  
  [Open →](alg-complexity.md){ .md-button .md-button--primary }

- :material-lightbulb-on-outline: **Algorithm strategies**  
  How to choose a problem-solving approach (brute force, divide & conquer, greedy, DP, backtracking).  
  [Open →](alg-strategies.md){ .md-button .md-button--primary }

</div>


## Practice tasks (recommended routine)
1. Solve 2–3 tasks without looking at notes.
2. Write a short “why it works” explanation (2–5 sentences).
3. Only then check hints / model solutions.

!!! warning "If you're stuck"
    Don’t jump to the solution. First write: what you know, what you tried, and the smallest example where it fails. That’s usually enough to unblock you.

## Before moving on

You’re ready for the next block when you can:

- Choose a data structure and justify the choice in one sentence.
- Estimate roughly how work grows for a simple loop, nested loop, or basic recursion.
- Spot obvious inefficiencies (extra passes, unnecessary copying, repeated work).

> Strong programmers don’t memorize solutions - they build tools for thinking.

![Hero image](https://i.imgur.com/7DNziXu.png)
